## 字典树的经典题

-   时间复杂度
    -   查询和插入$O(logN)$
-   适用范围
    -   ==异或和==
    -   前缀查询

#### [421. 数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/) 中等 yxc 贪心+字典树

-   异或值最大，从最高位开始相反匹配，如果当前值为1，则尽量找值为0的位。当没有值为0的位时，再考虑找值为1的位。
-   字典树的数组大小为`n*26`

```cpp

class Solution {
public:
    const int static N = 6e5+5;
     int son[N][2], idx = 0, end[N];
    int findMaximumXOR(vector<int>& nums) {
        int res = 0;
        for(auto x: nums){
            insert(x);
            int t = query(x);
            res = max(res, t^x);
        }
        return res;
    }
    int query(int x){
        int p = 0, temp = 0;
        for(int i = 30; i >= 0; i--){
            int u = (x>>i)&1;
            if(son[p][!u]) {
                temp = temp*2 + !u;
                p = son[p][!u];
            }else{
                temp = temp*2 + u;
                p = son[p][u];
            }
        }
        return temp;
    }
    
    void insert(int x){
        int p = 0;
        for(int i = 30; i >= 0; i--){
            int u = (x>>i)&1;
            if(!son[p][u]) son[p][u] = ++idx;
            p = son[p][u];
        }
    }
    
    
};
```

#### [677. 键值映射](https://leetcode-cn.com/problems/map-sum-pairs/) 中等 哈希表+字典树

#### 方法1：数组模拟字典树

-   如果key没有对应的值，就直接插入；如果key有值，就需要更新，此时对于每个节点中存储的值，需要计算一个差值再进行统计。

```cpp
class MapSum {
public:
    /** Initialize your data structure here. */
    unordered_map<string, int> mp;
    const int static N = 1e5+6;
    int son[N][26], s[N], idx = 0;
    MapSum() {
        memset(son, 0, sizeof son);
        memset(s, 0, sizeof s);
    }
    
    void insert(string key, int val) {
        int cur = val;
        if(mp.count(key)) cur -= mp[key];
        mp[key] = val;
        int p = 0;
        for(auto &c: key){
            int u = c - 'a';
            if(!son[p][u]) son[p][u] = ++idx;
            p = son[p][u];
            s[p] += cur;
        }
    }
    
    int sum(string prefix) {
        int p = 0;
        for(auto &c: prefix){
            int u = c - 'a';
            if(!son[p][u]) return 0;
            p = son[p][u];
        }
        return s[p];
    }
};

```

#### 方法2：结构体实现字典树

-   结构体版本耗时更长

```cpp
class MapSum {
public:
    /** Initialize your data structure here. */
    unordered_map<string, int> mp;
    struct Trie{
        int sum;
        Trie* son[26];
        Trie(){
            sum = 0;
            for(int i = 0; i < 26; i++){
                son[i] = nullptr;
            }
        }
    };
    Trie* root = new Trie();
    MapSum() {
        
    }
    
    void insert(string key, int val) {
        auto p = root;
        int cur = val;
        if(mp.count(key)) cur -= mp[key]; 
         mp[key] = val;
        for(auto &c: key){
            int u = c -'a';
            if(!p->son[u]) p ->son[u] = new Trie();
            p = p->son[u];
            p->sum += cur;
        }
    }
    
    int sum(string key) {
        auto p = root;
        for(auto &c: key){
            int u = c -'a';
            if(!p->son[u]) return 0;
            p = p->son[u];
        }
        return p->sum;
    }
};

```

#### [745. 前缀和后缀搜索](https://leetcode-cn.com/problems/prefix-and-suffix-search/) 困难 yxc

-   构造单词suffix#prefix
-   特殊处理非字母字符

```cpp
class WordFilter {
public:
    struct Trie{
        int idx;
        Trie* son[27];
        Trie(){
            idx = -1;
            for(int i = 0; i < 27; i++){
                son[i] = nullptr;
            }
        }
    };
    Trie* root = new Trie();
    void insert(string word, int idx){
        auto p = root;

        for(auto &c: word){
            int u = c=='#'? 26: c -'a';
            
            if(!p->son[u]) p ->son[u] = new Trie();
            p = p->son[u];
            p->idx = idx;
        }
    }
    
    int query(string word){
        auto p = root;
        for(auto &c: word){
            int u = c=='#'? 26: c -'a';
            if(!p->son[u]) return -1;
            p = p->son[u];
        }
        return p->idx;
    }
    WordFilter(vector<string>& words) {
        for(int i = 0; i < words.size(); i++){
            auto s = '#' + words[i];
            insert(s, i);
            //#apple 
            //e#apple
            //le#apple
            for(int j = words[i].size()-1; j >= 0; j--){
                s = words[i][j] + s;
                insert(s, i);
            }
        }
    }
    
    int f(string prefix, string suffix) {
        return query(suffix+'#'+prefix);
    }
};

```

#### [1707. 与数组中元素的最大异或值](https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/) 困难 yxc