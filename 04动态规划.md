## 动态规划

-   时间复杂度
    -   依赖于数组的维度
-   适用范围
    -   求最值和数量
-   常考类型
    -   三角形
        -   [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/) 中等 
    -   背包问题
        -   [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/) 中等
        -   [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/) 中等 
        -   [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/) 中等
    -   线性DP
        -   [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) 中等
        -   [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) 困难
        -   [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) 简单
        -   [256. 粉刷房子](https://leetcode-cn.com/problems/paint-house/) 简单 
        -   [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/) 中等
        -   [1406. 石子游戏 III](https://leetcode-cn.com/problems/stone-game-iii/) 困难
    -   数位DP
        -   [233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/) 困难 
    -   区间DP
        -   [1000. 合并石头的最低成本](https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/) 困难
        -   [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/) 困难
        -   [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/) 中等

## 经典例题

#### [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/) 中等 二维费用01背包

-   这道题放了很久了，一直不会做。直到这次学了二维费用背包才掌握一点皮毛。
-   数字0的限制看成第一维
-   数字1的限制看成第二维
-   集合表示满足条件的数量个数，价值为1。
-   如果下次不懂就建议先学AcWing的背包问题

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int f[105][105];
        memset(f, 0, sizeof f);
        int t = strs.size();
        for(auto &s: strs){
            int a = 0, b = 0;
            for(auto &c: s){
                if(c == '0') a++;
                else b++;
            }
            for(int j = m; j >= a; j--){
                for(int k = n; k >= b; k--){
                    f[j][k] = max(f[j][k], f[j-a][k-b] + 1);
                }
            }
        }
        return f[m][n];
    }
};
```



#### [334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/) 中等

##### 方法1：线性版

-   最长上升子序列的简化版
-   两个变量定义表示长度为1和2的子序列

```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int n = nums.size();
        vector<int> q(2,INT_MAX);
        for(auto a: nums){
            int k = 2;
            while(k > 0 && q[k-1] >= a) k--;
            if(k == 2) return true;
            q[k] = a;
        }
        return false;
    }
};
```

##### 方法2：上升子序列版

```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int n = nums.size();
        int len = 0;
        vector<int> q(n+1);
        for(int i = 0; i < nums.size(); i++){
            int l = 0, r = len;
            while(l < r){
                int mid = l + r + 1>>1;
                if(q[mid] < nums[i]) l = mid;
                else r = mid - 1;
            }
            len = max(len, r+1);
            q[r+1] = nums[i];
        }
        return len >= 3;
    }
};
```

#### [233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/) 困难 数位DP

-   统计每个位上的1有多少个

```cpp
class Solution {
public:
    int countDigitOne(int x) {
        // 统计1的数量123 4 567
        // 第一种情况：当左边为0~123时，当前位置取1，即(0~122)1(0~999) 共计left*p种状态
        // 第二种情况：当左边为123时，如果当前位置刚好等于1，则共有(0~567)共right+1种状态，如果当前值大于1，则右边有(0~999)种状态
        int a[20];
        int n = 0;
        do{
            a[n++] = x%10;
            x /= 10;
        }while(x);
        long long res = 0;
        for(int i = 0; i < n; i++){
            int left = 0, right = 0, p = 1;
            //从后往前枚举，先计算出left的值 123 4 567
            for(int j = n-1; j > i; j--){
                left = left*10 + a[j];
            }

            for(int j = i-1; j >= 0; j--){
                right = right*10 + a[j];
                p *= 10;
            }
            res += left*p;
            if(a[i]==1) res += right+1;
            else if(a[i] > 1)res += p;
        }
        return res;
    }
};
```



#### [583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/) 中等 区间DP

-   最长公共子序列的变体

```cpp
class Solution {
public:
    int minDistance(string s, string t) {
        int m = s.size(), n = t.size();
        int res = m + n;
        s = '#' + s;
        t = '#' + t;
        vector<vector<int>> f(m+1, vector<int>(n+1));
        int len = 0;
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(s[i]==t[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
                else{
                    f[i][j] = max(f[i][j], max(f[i-1][j], f[i][j-1]));
                }
                len = max(len, f[i][j]);
            }
        }
        return res - 2*len;
    }
};
```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) 困难 二维字符串DP

-   注意两个字符串的下标都是从1开始
-   删除`f[i][j] = f[i-1][j]+1`删掉`a[i]`最后一个。
-   增加`f[i][j] = f[i][j-1]+1` 因为增加的这一个必须和`b[j]`相等
-   替换`f[i-1][j-1] +(s[i] != t[j])` 只有当`a[i] != b[j]`的时候才增加一步操作

```cpp
class Solution {
public:
    int minDistance(string s, string t) {
        int m = s.size(), n = t.size();
        //使字符串下标从1开始
        s ="#" + s;
        t ="#" + t;
        vector<vector<int>> f(m+1, vector<int>(n+1));
        //初始化
        for(int i = 0; i <= m; i++) f[i][0] = i;
        for(int j = 0; j <= n; j++) f[0][j] = j;
        //dp
        for(int i = 1; i <= m; i ++){
            for(int j = 1; j <= n; j++){
                f[i][j] = min(f[i-1][j], f[i][j-1]) + 1;
                f[i][j] = min(f[i][j], f[i-1][j-1] +(s[i] != t[j]));
            }
        }
        return f[m][n];
    }
};
```

#### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/) 中等 左右两边乘积 

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/) 简单 yxc 一维dp

#### 方法1：一维数组dp

-   注意初始化的时候，只有一个元素，则最佳值就是当前这个元素。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        //dp[i]表示以i结尾的最长连续子数组和
        //转移方程：dp[i]大于0就追加在前面的数组后面，否则独立成一个新的数组。
        int n = nums.size();
        vector<int> dp(n+1);
        int sum= 0;
        dp[0] = nums[0];
        int res = dp[0];
        for(int i = 1; i < n; i++){
            if(dp[i-1] > 0) dp[i] = dp[i-1] + nums[i];
                else dp[i] = nums[i];
            res = max(dp[i], res);
        }
        return res;
    }
};
```

#### 方法2：变量

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int prefixSum = nums[0];
        int res = nums[0];
        for(int i = 1; i < n; i++){
            if(prefixSum > 0) prefixSum += nums[i];
            else 
                prefixSum = nums[i];
            res = max(prefixSum, res);
        }
        return res;
    }
};
```



#### [152. 乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray/) 中等 二维DP [B站大佬](https://www.bilibili.com/video/av85659071?from=search&seid=1168981676077655216) 注意负数和零

#### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/) 中等 一维DP [hhj](https://www.youtube.com/watch?v=il8Oi21WZN0) 

#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) 中等 一维DP yj

#### 方法1：一维数组DP $O(n^2)$

-   初始化：长度都为1，结果也为1
-   转移方程：把当前值，接在比当前值小的位置上，并更新当前值的最大长度

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n+1,1);
        int res = 1;
        for(int i = 0; i < n; i++)
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i])
                    f[i] = max(f[i], f[j] + 1);
                res = max(res, f[i]);
            }
        return res;
    }
};
```

#### 方法2：贪心+二分 $O(nlogn)$

-   注意初始状态
-   二分要用模板2

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> q(n+1);
        int res = 0;
        for(int i = 0; i < n; i++){
            int l = 0, r = res;
            // 6 7 7 8 
            // 如果当前值为7 一定要接在第一个数后面
            // mid < target
            while(l < r){
                int mid = l + r + 1 >> 1;
                if(q[mid] < nums[i]) l = mid;
                else r = mid - 1;
            }
            res = max(res, r+1);
            q[r+1] = nums[i];
        }
        return res;
    }
};
```



#### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/) 中等 二维DP 

-   自底向上
-   转移方程：`f[i-1][j] = min(f[i][j],f[i][j+1]) + tr[i-1][j]`
-   使用滚动数组优化，中间可以用一个数组过渡。

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& tr) {
        int n = tr.size();
        vector<int> f(tr[n-1].begin(), tr[n-1].end());
        for(int i = n-2; i >= 0; i --){
            vector<int> temp(f);
            for(int j = 0; j < tr[i].size(); j++){
                temp[j] = min(f[j], f[j+1]) + tr[i][j];
            }
            f = temp;
        }
        return f[0];
    }
};
```

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) 简单 遍历维护最小买入位置

#### [256. 粉刷房子](https://leetcode-cn.com/problems/paint-house/) 简单 yj 三个变量扩展

#### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/) 简单 yj 斐波那契数列扩展

#### [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/) 中等 hhj

#### [1383. 最大的团队表现值](https://leetcode-cn.com/problems/maximum-performance-of-a-team/) 困难 yxc

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) 中等 yxc

#### [678. 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/) 中等 hhj 二维dp

#### [1043. 分隔数组以得到最大和](https://leetcode-cn.com/problems/partition-array-for-maximum-sum/) 一维DP 从后往前划分区间 hhj

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/) 中等 DFS DP  hhj

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/) 中等 DP hhj 

#### [873. 最长的斐波那契子序列的长度](https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/) 中等 hhj 二维dp

#### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/) 中等 hhj 二维dp 记忆化递归

#### [1218. 最长定差子序列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/)

#### [1027. 最长等差数列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence/) 

#### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/) yxc 字符串二维dp

-   `f[i][j] `表示`s[1~i]`中子序列可以匹配`t[1~j]`字符串的数量
-   注意即使用了long long也会溢出，所以直接取个模
-   集合划分：`s[i]`选还是不选，不选总是成立；选，需要两个字符相等才成立；
-   初始状态：当`t`是空串时，`s`串总是存在满足条件的1种方案。

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int n = s.size(), m = t.size();
        typedef long long LL;
        s = '#' + s, t = '#'+t;
        vector<vector<LL>> f(n+1, vector<LL>(m+1));
        const int MOD = 1e9+7;
        for(int i = 0; i <= n; i++) f[i][0] = 1;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                f[i][j] = f[i-1][j];
                if(s[i] == t[j] ) f[i][j] = (f[i][j] + f[i-1][j-1])%MOD;
            }
        }
        return f[n][m];
    }
};
```

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) 中等 yj

-   注意第一行和第一列的预处理，是数值的前缀和而不是直接赋值。

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        if(!n || grid[0].empty()) return 0;
        int m = grid[0].size();
        vector<vector<int>> f(n+1, vector<int>(m+1));
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(i==1) f[i][j] = f[i][j-1] + grid[i-1][j-1];
                else if(j==1) f[i][j] = f[i-1][j] + grid[i-1][j-1];
                else{
                    f[i][j] = min(f[i-1][j], f[i][j-1]) + grid[i-1][j-1];
                }
            }
        }
        return f[n][m];
    }
};
```

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/) 中等 01背包

#### 方法1：DFS

-   **36 / 116** 个通过测试用例
-   每次决策，都是选与不选

```cpp
class Solution {
public:
    bool flag = false;
    void dfs(vector<int>&nums, int u, int sum){
        if(flag) return;
        if(!sum){
            flag = true;
            return;
        }
        if(u >= nums.size()) return ;
        //选
        dfs(nums, u+1, sum - nums[u]);
        //不选
        dfs(nums, u+1, sum);
    }
    bool canPartition(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int sum = 0;
        for(auto x: nums) sum += x;
        if(sum%2) return false;
        dfs(nums, 0, sum/2);
        return flag;
    }
};
```

#### 方法2：01背包+滚动数组

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x: nums) sum += x;
        if(sum%2) return false;
        sum >>= 1;
        vector<int>f(sum+1);
        for(int i = 0; i < n; i++){
            for(int j = sum; j >= nums[i]; j--){
                f[j] = max(f[j], f[j - nums[i]] + nums[i]);
            }
        }
        return f[sum] == sum;
    }
};
```

#### 方法3： 01背包+通俗易懂

-   注意第一维数组开始的下标是0还是1

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x: nums) sum += x;
        if(sum%2==1) return false;
        // 不要用右移 容易写错 不好debug 如果写成sum>>1很致命
        sum >>= 1;
        vector<vector<bool>>f(n+1, vector<bool>(sum+1));
        // f[i][j]表示能否使用0~i中的数组成和为j的数
        f[0][0] = true;
        // 一个都不选 且和为0 确实是成立的
        for(int i = 1; i <= n; i++){
            for(int j = 0; j <= sum; j++){
                // 不选nums[i]
                f[i][j] = f[i-1][j];
                // 有条件的选择
                if(j >= nums[i-1] ) f[i][j] = f[i][j] || f[i-1][j-nums[i-1]];
            }
        }
        return f[n][sum];
    }
};
```

#### 方法4： 01背包+滚动数组+通俗易懂

-   注意
    -   内层循环：从右往左遍历，`j--`
    -   初始化：从前`0`件物品中凑成`0`是成立的，所以为`true`

```
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x: nums) sum += x;
        if(sum&1) return false;
        sum >>= 1;
        vector<int> f(sum+1);
        f[0] = true;
        for(int i = 1; i <= n; i++){
            for(int j = sum; j >= nums[i-1]; j--){
               f[j] = f[j] || f[j-nums[i-1]];
            }
        }
        return f[sum];
    }
};
```

#### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/) 中等 区间DP

#### 方法1： 最长公共子序列

-   注意，最长的公共子序列可能在中间，而不是在最后一个位置。

```cpp
class Solution {
public:
    int longestPalindromeSubseq(string a) {
        string b = a;
        reverse(b.begin(), b.end());
        int n = a.size();
        a = "#" + a;
        b = "#" + b;
        vector<vector<int>> f(n+1, vector<int>(n+1));
        int res = 0;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= n; j++){
                if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
                else f[i][j] = max(f[i-1][j], f[i][j-1]);
                res = max(res, f[i][j]);
            }
        }
        
        return res;
    }
};
```

#### [446. 等差数列划分 II - 子序列](https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/) 困难 二维DP yxc

-   `dp[i][d]`表示长度大于等于2的子序列，以`a[i]`结尾，且公差为`d`的数量
-   转移方程
    -   `dp[i][d] = 1 + d[1~k][d]` 这里的1表示`a[i]`和`a[k]`组合为一个长度大于等于2的子序列，同时也可以将这两个元素拼接到前面的子序列后面
    -   枚举`i`前面的元素，查看所有与`a[i]`公差为`d`的元素

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        typedef long long LL;
        int n = nums.size();
        vector<unordered_map<LL, LL>> f(n);
        
        int res = 0;
        for(int i = 0; i < n; i++){
            for(int k = 0; k < i; k++){
                auto d = (LL) nums[i] - nums[k];
                auto it = f[k].find(d);
                LL t = 0;
                if(it != f[k].end()){
                    t = it->second;
                    res += t;
                }
                f[i][d] += 1 + t;
            }
        }
        return res;
    }
};
```



#### [1000. 合并石头的最低成本](https://leetcode-cn.com/problems/minimum-cost-to-merge-stones/) 困难 hhj

-   凑成1堆和K-1堆
-   合成大堆时，总的开销是固定的。
-   当存在K堆时，加上这个区间的部分和，就能合成一个大堆。

```cpp
class Solution {
public:
    int dp[33][33][33],sum[33];
    int mergeStones(vector<int>& stones, int K) {
        int  n = stones.size();
        if( (n-1) % (K-1) ) return -1;
        memset(dp,0x3f,sizeof (dp));
        sum[0] = 0;
        for(int i = 1;i<=n;++i){
            dp[i][i][1] = 0;
            sum[i] = sum[i-1] + stones[i-1];
        }
        //区间DP
        for(int len = 2; len <= n; len++){
            for(int i = 1; i + len -1 <= n; i++){
                int j = i + len - 1;
                for(int k = 2; k <= K; k++){
                    for(int m = i; m <= j; m++){
                        dp[i][j][k] = min(dp[i][j][k] ,dp[i][m][1] + dp[m+1][j][k-1]);
                    }
                }
                if(dp[i][j][K] < 0x3f3f3f3f){
                    dp[i][j][1] = dp[i][j][K] + sum[j] - sum[i-1];
                }
            }
        }
        
        return dp[1][n][1];
    
    }
};
```

