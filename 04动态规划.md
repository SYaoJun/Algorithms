#### [334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/) 中等

#### 方法1：线性版

-   最长上升子序列的简化版
-   两个变量定义表示长度为1和2的子序列

```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int n = nums.size();
        vector<int> q(2,INT_MAX);
        for(auto a: nums){
            int k = 2;
            while(k > 0 && q[k-1] >= a) k--;
            if(k == 2) return true;
            q[k] = a;
        }
        return false;
    }
};
```

#### 方法2：上升子序列版

```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int n = nums.size();
        int len = 0;
        vector<int> q(n+1);
        for(int i = 0; i < nums.size(); i++){
            int l = 0, r = len;
            while(l < r){
                int mid = l + r + 1>>1;
                if(q[mid] < nums[i]) l = mid;
                else r = mid - 1;
            }
            len = max(len, r+1);
            q[r+1] = nums[i];
        }
        return len >= 3;
    }
};
```

#### [233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/) 困难 数位DP

#### [583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/) 中等

-   最长公共子序列的变体

```cpp
class Solution {
public:
    int minDistance(string s, string t) {
        int m = s.size(), n = t.size();
        int res = m + n;
        s = '#' + s;
        t = '#' + t;
        vector<vector<int>> f(m+1, vector<int>(n+1));
        int len = 0;
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(s[i]==t[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
                else{
                    f[i][j] = max(f[i][j], max(f[i-1][j], f[i][j-1]));
                }
                len = max(len, f[i][j]);
            }
        }
        return res - 2*len;
    }
};
```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) 困难 二维字符串DP

-   注意两个字符串的下标都是从1开始
-   删除`f[i][j] = f[i-1][j]+1`删掉`a[i]`最后一个。
-   增加`f[i][j] = f[i][j-1]+1` 因为增加的这一个必须和`b[j]`相等
-   替换`f[i-1][j-1] +(s[i] != t[j])` 只有当`a[i] != b[j]`的时候才增加一步操作

```cpp
class Solution {
public:
    int minDistance(string s, string t) {
        int m = s.size(), n = t.size();
        //使字符串下标从1开始
        s ="#" + s;
        t ="#" + t;
        vector<vector<int>> f(m+1, vector<int>(n+1));
        //初始化
        for(int i = 0; i <= m; i++) f[i][0] = i;
        for(int j = 0; j <= n; j++) f[0][j] = j;
        //dp
        for(int i = 1; i <= m; i ++){
            for(int j = 1; j <= n; j++){
                f[i][j] = min(f[i-1][j], f[i][j-1]) + 1;
                f[i][j] = min(f[i][j], f[i-1][j-1] +(s[i] != t[j]));
            }
        }
        return f[m][n];
    }
};
```

#### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/) 中等 左右两边乘积 

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/) 简单 yxc 一维dp

#### 方法1：一维数组dp

-   注意初始化的时候，只有一个元素，则最佳值就是当前这个元素。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        //dp[i]表示以i结尾的最长连续子数组和
        //转移方程：dp[i]大于0就追加在前面的数组后面，否则独立成一个新的数组。
        int n = nums.size();
        vector<int> dp(n+1);
        int sum= 0;
        dp[0] = nums[0];
        int res = dp[0];
        for(int i = 1; i < n; i++){
            if(dp[i-1] > 0) dp[i] = dp[i-1] + nums[i];
                else dp[i] = nums[i];
            res = max(dp[i], res);
        }
        return res;
    }
};
```

#### 方法2：变量

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int prefixSum = nums[0];
        int res = nums[0];
        for(int i = 1; i < n; i++){
            if(prefixSum > 0) prefixSum += nums[i];
            else 
                prefixSum = nums[i];
            res = max(prefixSum, res);
        }
        return res;
    }
};
```



#### [152. 乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray/) 中等 二维DP [B站大佬](https://www.bilibili.com/video/av85659071?from=search&seid=1168981676077655216) 注意负数和零

#### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/) 中等 一维DP [hhj](https://www.youtube.com/watch?v=il8Oi21WZN0) 

#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) 中等 一维DP yj

#### 方法1：一维数组DP $O(n^2)$

-   初始化：长度都为1，结果也为1
-   转移方程：把当前值，接在比当前值小的位置上，并更新当前值的最大长度

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n+1,1);
        int res = 1;
        for(int i = 0; i < n; i++)
            for(int j = 0; j < i; j++){
                if(nums[j] < nums[i])
                    f[i] = max(f[i], f[j] + 1);
                res = max(res, f[i]);
            }
        return res;
    }
};
```

#### 方法2：贪心+二分 $O(nlogn)$

-   注意初始状态
-   二分要用模板2

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> q(n+1);
        int res = 0;
        for(int i = 0; i < n; i++){
            int l = 0, r = res;
            // 6 7 7 8 
            // 如果当前值为7 一定要接在第一个数后面
            // mid < target
            while(l < r){
                int mid = l + r + 1 >> 1;
                if(q[mid] < nums[i]) l = mid;
                else r = mid - 1;
            }
            res = max(res, r+1);
            q[r+1] = nums[i];
        }
        return res;
    }
};
```



#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) 困难 二维DP 极客视频 

#### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/) 中等 二维DP 

-   自底向上
-   转移方程：`f[i-1][j] = min(f[i][j],f[i][j+1]) + tr[i-1][j]`
-   使用滚动数组优化，中间可以用一个数组过渡。

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& tr) {
        int n = tr.size();
        vector<int> f(tr[n-1].begin(), tr[n-1].end());
        for(int i = n-2; i >= 0; i --){
            vector<int> temp(f);
            for(int j = 0; j < tr[i].size(); j++){
                temp[j] = min(f[j], f[j+1]) + tr[i][j];
            }
            f = temp;
        }
        return f[0];
    }
};
```



#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) 简单 遍历维护最小买入位置

#### [256. 粉刷房子](https://leetcode-cn.com/problems/paint-house/) 简单 yj 三个变量扩展

#### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/) 简单 yj 斐波那契数列扩展

#### [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/) 中等 hhj

#### [1383. 最大的团队表现值](https://leetcode-cn.com/problems/maximum-performance-of-a-team/) 困难 yxc

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) 中等 yxc

#### [678. 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/) 中等 hhj 二维dp

#### [1043. 分隔数组以得到最大和](https://leetcode-cn.com/problems/partition-array-for-maximum-sum/) 一维DP 从后往前划分区间 hhj

#### [494. 目标和](https://leetcode-cn.com/problems/target-sum/) 中等 DFS DP  hhj

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/) 中等 DP hhj 

#### [873. 最长的斐波那契子序列的长度](https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/) 中等 hhj 二维dp

#### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/) 中等 hhj 二维dp 记忆化递归

#### [1218. 最长定差子序列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/)

#### [1027. 最长等差数列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence/) 

#### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/) yxc 字符串二维dp

-   `f[i][j] `表示`s[1~i]`中子序列可以匹配`t[1~j]`字符串的数量
-   注意即使用了long long也会溢出，所以直接取个模
-   集合划分：`s[i]`选还是不选，不选总是成立；选，需要两个字符相等才成立；
-   初始状态：当`t`是空串时，`s`串总是存在满足条件的1种方案。

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int n = s.size(), m = t.size();
        typedef long long LL;
        s = '#' + s, t = '#'+t;
        vector<vector<LL>> f(n+1, vector<LL>(m+1));
        const int MOD = 1e9+7;
        for(int i = 0; i <= n; i++) f[i][0] = 1;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                f[i][j] = f[i-1][j];
                if(s[i] == t[j] ) f[i][j] = (f[i][j] + f[i-1][j-1])%MOD;
            }
        }
        return f[n][m];
    }
};
```

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) 中等 yj

-   注意第一行和第一列的预处理，是数值的前缀和而不是直接赋值。

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        if(!n || grid[0].empty()) return 0;
        int m = grid[0].size();
        vector<vector<int>> f(n+1, vector<int>(m+1));
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(i==1) f[i][j] = f[i][j-1] + grid[i-1][j-1];
                else if(j==1) f[i][j] = f[i-1][j] + grid[i-1][j-1];
                else{
                    f[i][j] = min(f[i-1][j], f[i][j-1]) + grid[i-1][j-1];
                }
            }
        }
        return f[n][m];
    }
};
```

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/) 中等 01背包

#### 方法1：DFS

-   **36 / 116** 个通过测试用例
-   每次决策，都是选与不选

```cpp
class Solution {
public:
    bool flag = false;
    void dfs(vector<int>&nums, int u, int sum){
        if(flag) return;
        if(!sum){
            flag = true;
            return;
        }
        if(u >= nums.size()) return ;
        //选
        dfs(nums, u+1, sum - nums[u]);
        //不选
        dfs(nums, u+1, sum);
    }
    bool canPartition(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int sum = 0;
        for(auto x: nums) sum += x;
        if(sum%2) return false;
        dfs(nums, 0, sum/2);
        return flag;
    }
};
```

#### 方法2：01背包+滚动数组

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x: nums) sum += x;
        if(sum%2) return false;
        sum >>= 1;
        vector<int>f(sum+1);
        for(int i = 0; i < n; i++){
            for(int j = sum; j >= nums[i]; j--){
                f[j] = max(f[j], f[j - nums[i]] + nums[i]);
            }
        }
        return f[sum] == sum;
    }
};
```

#### 方法3： 01背包+通俗易懂

-   注意第一维数组开始的下标是0还是1

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x: nums) sum += x;
        if(sum%2==1) return false;
        // 不要用右移 容易写错 不好debug 如果写成sum>>1很致命
        sum >>= 1;
        vector<vector<bool>>f(n+1, vector<bool>(sum+1));
        // f[i][j]表示能否使用0~i中的数组成和为j的数
        f[0][0] = true;
        // 一个都不选 且和为0 确实是成立的
        for(int i = 1; i <= n; i++){
            for(int j = 0; j <= sum; j++){
                // 不选nums[i]
                f[i][j] = f[i-1][j];
                // 有条件的选择
                if(j >= nums[i-1] ) f[i][j] = f[i][j] || f[i-1][j-nums[i-1]];
            }
        }
        return f[n][sum];
    }
};
```

#### 方法4： 01背包+滚动数组+通俗易懂

-   注意
    -   内层循环：从右往左遍历，`j--`
    -   初始化：从前`0`件物品中凑成`0`是成立的，所以为`true`

```
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x: nums) sum += x;
        if(sum&1) return false;
        sum >>= 1;
        vector<int> f(sum+1);
        f[0] = true;
        for(int i = 1; i <= n; i++){
            for(int j = sum; j >= nums[i-1]; j--){
               f[j] = f[j] || f[j-nums[i-1]];
            }
        }
        return f[sum];
    }
};
```



