1.  #### [233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/) 困难 数位DP

2.  #### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/) 中等 左右两边乘积 

3.  #### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/) 简单 yxc

4.  #### [152. 乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray/) 中等 二维DP [B站大佬](https://www.bilibili.com/video/av85659071?from=search&seid=1168981676077655216) 注意负数和零

5.  #### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/) 中等 一维DP [hhj](https://www.youtube.com/watch?v=il8Oi21WZN0) 

6.  #### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/) 中等 一维DP yj

7.  #### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/) 困难 二维DP 极客视频 

8.  #### [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/) 中等 一维DP yj  yxc

9.  #### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) 简单 遍历维护最小买入位置

10.  #### [256. 粉刷房子](https://leetcode-cn.com/problems/paint-house/) 简单 yj 三个变量扩展

11.  #### [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/) 简单 yj 斐波那契数列扩展

12.  #### [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/) 中等 hhj

13.  #### [1383. 最大的团队表现值](https://leetcode-cn.com/problems/maximum-performance-of-a-team/) 困难 yxc

14.  #### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) 中等 yxc

15.  #### [678. 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/) 中等 hhj 二维dp

16.  #### [1043. 分隔数组以得到最大和](https://leetcode-cn.com/problems/partition-array-for-maximum-sum/) 一维DP 从后往前划分区间 hhj

17.  #### [494. 目标和](https://leetcode-cn.com/problems/target-sum/) 中等 DFS DP  hhj

18.  #### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/) 中等 DP hhj 

19.  #### [873. 最长的斐波那契子序列的长度](https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/) 中等 hhj 二维dp

20.  #### [877. 石子游戏](https://leetcode-cn.com/problems/stone-game/) 中等 hhj 二维dp 记忆化递归

21.  #### [1218. 最长定差子序列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/)

22.  #### [1027. 最长等差数列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence/)

23.  #### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/) yxc 字符串二维dp

-   `f[i][j] `表示`s[1~i]`中子序列可以匹配`t[1~j]`字符串的数量
-   注意即使用了long long也会溢出，所以直接取个模
-   集合划分：`s[i]`选还是不选，不选总是成立；选，需要两个字符相等才成立；
-   初始状态：当`t`是空串时，`s`串总是存在满足条件的1种方案。

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int n = s.size(), m = t.size();
        typedef long long LL;
        s = '#' + s, t = '#'+t;
        vector<vector<LL>> f(n+1, vector<LL>(m+1));
        const int MOD = 1e9+7;
        for(int i = 0; i <= n; i++) f[i][0] = 1;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                f[i][j] = f[i-1][j];
                if(s[i] == t[j] ) f[i][j] = (f[i][j] + f[i-1][j-1])%MOD;
            }
        }
        return f[n][m];
    }
};
```

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/) 中等 yj

-   注意第一行和第一列的预处理，是数值的前缀和而不是直接赋值。

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        if(!n || grid[0].empty()) return 0;
        int m = grid[0].size();
        vector<vector<int>> f(n+1, vector<int>(m+1));
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(i==1) f[i][j] = f[i][j-1] + grid[i-1][j-1];
                else if(j==1) f[i][j] = f[i-1][j] + grid[i-1][j-1];
                else{
                    f[i][j] = min(f[i-1][j], f[i][j-1]) + grid[i-1][j-1];
                }
            }
        }
        return f[n][m];
    }
};
```

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/) 中等 01背包

#### 方法1：DFS

-   **36 / 116** 个通过测试用例
-   每次决策，都是选与不选

```cpp
class Solution {
public:
    bool flag = false;
    void dfs(vector<int>&nums, int u, int sum){
        if(flag) return;
        if(!sum){
            flag = true;
            return;
        }
        if(u >= nums.size()) return ;
        //选
        dfs(nums, u+1, sum - nums[u]);
        //不选
        dfs(nums, u+1, sum);
    }
    bool canPartition(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int sum = 0;
        for(auto x: nums) sum += x;
        if(sum%2) return false;
        dfs(nums, 0, sum/2);
        return flag;
    }
};
```

#### 方法2：01背包+滚动数组

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x: nums) sum += x;
        if(sum%2) return false;
        sum >>= 1;
        vector<int>f(sum+1);
        for(int i = 0; i < n; i++){
            for(int j = sum; j >= nums[i]; j--){
                f[j] = max(f[j], f[j - nums[i]] + nums[i]);
            }
        }
        return f[sum] == sum;
    }
};
```

#### 方法3： 01背包+通俗易懂

-   注意第一维数组开始的下标是0还是1

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x: nums) sum += x;
        if(sum%2==1) return false;
        // 不要用右移 容易写错 不好debug 如果写成sum>>1很致命
        sum >>= 1;
        vector<vector<bool>>f(n+1, vector<bool>(sum+1));
        // f[i][j]表示能否使用0~i中的数组成和为j的数
        f[0][0] = true;
        // 一个都不选 且和为0 确实是成立的
        for(int i = 1; i <= n; i++){
            for(int j = 0; j <= sum; j++){
                // 不选nums[i]
                f[i][j] = f[i-1][j];
                // 有条件的选择
                if(j >= nums[i-1] ) f[i][j] = f[i][j] || f[i-1][j-nums[i-1]];
            }
        }
        return f[n][sum];
    }
};
```

#### 方法4： 01背包+滚动数组+通俗易懂

-   注意
    -   内层循环：从右往左遍历，`j--`
    -   初始化：从前`0`件物品中凑成`0`是成立的，所以为`true`

```
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        int n = nums.size();
        for(auto x: nums) sum += x;
        if(sum&1) return false;
        sum >>= 1;
        vector<int> f(sum+1);
        f[0] = true;
        for(int i = 1; i <= n; i++){
            for(int j = sum; j >= nums[i-1]; j--){
               f[j] = f[j] || f[j-nums[i-1]];
            }
        }
        return f[sum];
    }
};
```



