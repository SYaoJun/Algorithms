## 题目

-   [5860. 从双倍数组中还原原数组](https://leetcode-cn.com/problems/find-original-array-from-doubled-array/) M-
-   考查点：哈希表+排序

## 思路

-   这道题的突破点在于排序后的二倍值一定在当前值后面，这里可以用哈希表来标记。当一个值没有在哈希表中出现，说明这是一个新值，我们在哈希表中将其二倍值加1，并且存储到待返回的源数组中。如果这个值在哈希表中出现过，说明这是一个二倍值，我们把这个数的出现次数减少。
-   遍历完成后，我们需要统计每个值是否出现次数恰好抵消，也就是哈希表中的value之和为0。
    -   若为零，则表示是满足要求的数组，返回源数组。
    -   若非零，则表示不满足，返回空数组。

## 代码

-   精简版：参考的灵茶山艾府的代码

```cpp
class Solution {
public:
    vector<int> findOriginalArray(vector<int>& a) {
        sort(a.begin(), a.end());
        int res = 0;
        unordered_map<int, int> mp;
        vector<int> b;
        for(auto &v: a){
            if(mp[v]==0){
                mp[2*v]++;
                b.push_back(v);
            }else{
                mp[v]--;
            }
        }
        for(auto &[k, v]: mp){
            if(v) res++;
        }
        if(res) return {};
        return b;
    }
};
```

-   笨比版：周赛的时候写了一个多小时，还被含0的数据错了两次，最后都没时间写其他题，难受。
    -   每次从数组中选出奇数来判断是否能找到二倍值的偶数。
    -   剩余的偶数全体除以2，继续按照步骤一判断，直到源数组数量足够，或者数组出现不满足的情况。
    -   注意数据0要先特判，不然就是听取WA声一片。比如[1,3,4,2,6,8]先把[1,3]的二倍值处理了，并且能找到对应的二倍值[2,6]，此时数组中还剩余[4,2]，我们将数组每个元素除以2，变成[2,1]，然后再把奇数拿出来找对应的二倍值偶数。

```cpp
class Solution {
public:
    vector<int> a;
    int n, m;
    bool tag = true;
    using LL = long long;
    vector<int> findOriginalArray(vector<int>& ch) {
        n = ch.size();
        if(n&1) return {};
        m = n/2;
        LL sum = 0;
        sort(ch.begin(), ch.end());
        for(auto &x: ch){
            sum += x;
        }
        if(sum == 0) return vector<int>(m);
        int k = 0;
        while(k < n && ch[k]==0) k++;
        if(k&1) return {};
        vector<int> t(ch.begin()+k, ch.end());
        a.resize(k/2);
        dfs(t, 1);
        if(!tag) return  {};
        return a;
    }
    void dfs(vector<int>& ch, int d){
        vector<int> b;
        if(a.size() >= m) return;
        for(int i = 0; i < ch.size(); i++){
            if(ch[i] % 2 == 1)
                b.push_back(ch[i]);
            if(a.size() + b.size() > m) {
                tag = false;
                return;
            }
        }
        unordered_map<int, int> mp;
        
        for(int i = 0; i < ch.size(); i++){
            if(ch[i] % 2 == 0 ){
                 mp[ch[i]]++;
            }
        }
        
        for(auto &x: b){
            if(mp[2*x]==0) {
                tag = false;
                return;
            }
            mp[2*x]--;
        }
        //剩下的数要重新计算
        vector<int> c;
         for(auto &[k, v]: mp){
            for(int j = 0; j < v; j++){
                c.push_back(k/2);
            }
        }
        for(auto &x: b) a.push_back(x*d);
        dfs(c, d*2);
    }
};
```



