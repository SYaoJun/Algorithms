#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/) yxc 单调栈

-   找右边第一个比当前值大的数，要构造一个单调递增的栈。
-   注意栈顶判断时候，要使用while循环。

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        int n = T.size();
        vector<int> res(n);
        stack<int> stk;
        for(int i = n-1; i >= 0; i--){
            while(stk.size() && T[stk.top()] <= T[i]) stk.pop();
            if(stk.empty()) res[i] = 0;
            else res[i] = stk.top() - i;
            stk.push(i); 
        }
        
        return res;
    }
};
```



#### [735. 行星碰撞](https://leetcode-cn.com/problems/asteroid-collision/) yj  单调栈

-   只有在右边是正数，左边是负数的时候，才会发生碰撞。
-   碰撞中要用while循环，一直到无冲突为止。

```cpp
class Solution {
public:
    vector<int> asteroidCollision(vector<int>& as) {
        vector<int> stk;
        int n = as.size();
        for(int i = 0; i < n; i++){
            stk.push_back(as[i]);
            while(stk.size() > 1){
                auto y = stk.back();
                stk.pop_back();
                auto x = stk.back();
                stk.pop_back();
                if(x > 0 && y < 0){
                    if(abs(x) == abs(y)) break;
                    else if(abs(x) < abs(y)){
                        stk.push_back(y);
                    }else{
                        stk.push_back(x);
                        break;
                    }
                }else{
                    stk.push_back(x);
                    stk.push_back(y);
                    break;
                }
            }
        }
        return stk;
    }
};
```

#### [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/) H+ 

-   先构造每行的数据，再计算。
-   注意矩阵为空的情况。

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m = matrix.size();
        if(!m) return 0;
        int n = matrix[0].size();
        if(!n) return 0;

        vector<vector<int>> h(m, vector<int>(n));
        int res = 0;
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                if(matrix[i][j]=='1') {
                    if(i) h[i][j] = 1 + h[i-1][j];
                    else h[i][j] = 1;
                }
            }
        }
        for(int i = 0; i < m; i++) res = max(res, largestRectangleArea(h[i]));
        return res;
    }
    int largestRectangleArea(vector<int>& h){
        stack<int> stk;
        int n = h.size();
        vector<int> l(n), r(n);

        for(int i = 0; i < n; i++){
            while(stk.size() && h[stk.top()] >= h[i]) stk.pop();
            if(stk.empty()) l[i] = -1;
            else l[i] = stk.top();
            stk.push(i);
        }
        stk = stack<int>();
        for(int i = n-1; i >= 0; i--){
            while(stk.size() && h[stk.top()] >= h[i]) stk.pop();
            if(stk.empty()) r[i] = n;
            else r[i] = stk.top();
            stk.push(i);
        }
        //计算结果
        int res = 0;
        for(int i = 0; i < n; i++){
            res = max(res, h[i]*(r[i] - l[i] - 1));
        }
        return res;
    }
};
```

#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) H-

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& h) {
        // 枚举每个柱子为顶的最大面积
        // 实质是找到当前柱子  左边第一个比它小的位置 和  右边第一个比它小的位置
        // 使用栈来实现
        
        int n = h.size();
        vector<int> l(n), r(n);
        
        stack<int> stk;
        for(int i = 0; i < n; i++) {
            while(stk.size() && h[stk.top()] >= h[i]) stk.pop();
            if(stk.empty()) l[i] = -1;
            else l[i] = stk.top();
            stk.push(i);
        }
        stk = stack<int>();
        for(int i = n-1; i >= 0; i--) {
            while(stk.size() && h[stk.top()] >= h[i]) stk.pop();
            if(stk.empty()) r[i] = n;
            else r[i] = stk.top();
            stk.push(i);
        }
        
        int res = 0;
        
        for(int i = 0; i < n; i++){
            res = max(res, h[i]*(r[i]-l[i]-1));
        }
        return res;
    }
};
```

#### [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/) 2021.09.08

-   简单模拟

```cpp
class StockSpanner {
public:
    // 下标和值
    stack<pair<int, int>> stk;
    int k = 0;
    StockSpanner() {
        
    }
    
    int next(int price) {
        k++;
        while(stk.size() && stk.top().second <= price) {
            stk.pop();
        }
       
        
        if(stk.empty()) {
            stk.push({k, price});
            return k;
        }
        else {
             auto t = stk.top();
            stk.push({k, price});
            return k - t.first;
        }
    }
};

/**
 * Your StockSpanner object will be instantiated and called as such:
 * StockSpanner* obj = new StockSpanner();
 * int param_1 = obj->next(price);
 */
```

#### [962. 最大宽度坡](https://leetcode-cn.com/problems/maximum-width-ramp/) M+ 2021.9.9

-   我的单调栈又白学了。
-   从前往后生成递减单调栈，从后往前依次弹出栈顶元素。

```cpp
class Solution {
public:
    int maxWidthRamp(vector<int>& nums) {
        //单调栈 没学到精髓呀
        stack<int> stk;
        int n = nums.size();
        for(int i = 0; i < n; i++){
            if(stk.empty() || nums[stk.top()] > nums[i])
                stk.push(i);
        }
        //从后往前遍历
        int res = 0;
        for(int j = n - 1; j >= 0; j--){
            while(stk.size() && nums[stk.top()] <= nums[j]){
                auto i = stk.top();
                stk.pop();
                res = max(res, j - i);
            }
        }
        return res;
    }
};
```





