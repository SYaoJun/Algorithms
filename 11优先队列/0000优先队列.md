## 优先队列

-   时间复杂度
    -   查询$O(log N)$
-   适用范围
    -   维护最小值和最大值
-   小根堆

```cpp
priority_queue<int, vector<int>, greater<>> pq;
```

## 经典例题

#### [373. 查找和最小的K对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/) 中等 优先队列 多路归并 小根堆

-   把最小的一组数放入小根堆中，然后每次取出最小的和，把下标往后移动。

```cpp
typedef vector<int> VI;

class Solution {
public:
    vector<vector<int>> kSmallestPairs(vector<int>& a, vector<int>& b, int k) {
        if (a.empty() || b.empty()) return {};
        int m = a.size(), n = b.size();
        priority_queue<VI, vector<VI>, greater<VI>> pq;
        for (int i = 0; i < n; i ++ ) 
                pq.push({a[0]+b[i], 0, i});
        vector<VI> res;
        while(k-- && pq.size()){
           auto t = pq.top();
            pq.pop();
             res.push_back({a[t[1]], b[t[2]]});
            if (t[1] + 1 < m)
                pq.push({a[t[1]+1]+b[t[2]], t[1]+1, t[2]});  
        }
        return res;
    }
};

```

#### [692. 前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/)   中等 hhj

#### [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)  困难 优先队列 yxc

#### [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/) 中等 yj 

#### [767. 重构字符串](https://leetcode-cn.com/problems/reorganize-string/) 中等 优先队列 yj 弹出两个

#### [378. 有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/) 中等 优先队列

#### [502. IPO](https://leetcode-cn.com/problems/ipo/) 困难 左程云 一个大根堆 一个小根堆 2021.09.08

-   后来自己写的时候发现，根本不需要小根堆，直接排个序就好了。
-   注意最多有`k`个项目。

```cpp
class Solution {
public:
    int findMaximizedCapital(int k, int w, vector<int>& p, vector<int>& c) {
        priority_queue<int> pq_set;
        vector<pair<int, int>> a;
        int n = p.size();
        for(int i = 0; i < n; i++){
            a.push_back({c[i], p[i]});
        }
        sort(a.begin(), a.end());
        int cnt = 0, j = 0;
        while(true){
            bool tag = false;
            if(pq_set.size()){
                auto u = pq_set.top();
                pq_set.pop();
                w += u;
                cnt++;
                tag = true;
            }
           while(j < n && a[j].first <= w) {
               pq_set.push(a[j++].second);
               tag = true;
           }
            
            if(!tag || cnt==k) break;
        }
        return w;
    }
};
```



#### [703. 数据流中的第 K 大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/) 简单 题解 数据流 好题  小根堆

#### [295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/) 困难 yxc  一个小根堆 一个大跟堆 

#### [352. 将数据流变为多个不相交区间](https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/) 困难 题解 set 

#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/) 困难 自定义小根堆

-   注意链表为空不能加入优先队列
-   掌握自定义优先队列排序规则

```cpp
class Solution {
public:
    struct cmp{
        bool operator()(ListNode* a, ListNode* b){
            return a->val > b->val;
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
            // 优先队列
            priority_queue<ListNode*, vector<ListNode*>, cmp> pq; 
            for(auto list: lists){
                if(list) pq.push(list);
            }
            auto dummy = new ListNode(0);
            auto p = dummy;
            while(pq.size()){
                auto t = pq.top();
                pq.pop();
                p->next = t;
                if(t->next) pq.push(t->next);
                p = p->next;
            }
            return dummy->next;
    }
};
```

#### [1439. 有序矩阵中的第 k 个最小数组和](https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/) H-

##### 小根堆

-   由于每行的值有序，所以我们考虑通过移动每行的指针，凑出最小值。
-   注意
    -   放入小根堆的值要去重
    -   更新值的时候需要加上偏移量

```cpp
class Solution {
public:
    typedef pair<int, vector<int>> PIV;
    int kthSmallest(vector<vector<int>>& mat, int k) {
        //小根堆 标准做法
        int m = mat.size(), n = mat[0].size();
        priority_queue<PIV, vector<PIV>, greater<>> pq;
        int sum = 0;
        vector<int> array;
        for(int i = 0; i < m; i++){
            sum += mat[i][0];
            array.push_back(0);
        }
        pq.push({sum, array});
        //去重
        set<vector<int>> st;
        st.insert(array);
        
        for(int i = 0; i < k; i++){
            auto [sum, array] = pq.top();
            pq.pop();
            if(i == k-1) return sum;
            
            for(int j = 0; j < m; j++){
                array[j]++;
                if(array[j] < n && st.find(array) == st.end()){
                    pq.push({sum+mat[j][array[j]]-mat[j][array[j]-1], array});
                    st.insert(array);
                }
                array[j]--;
            }
        }
        
        return -1;
    }
};
```

##### 暴力贪心

-   因为`k <= 200`所以每次与相邻的行相加，然后取前`200`个最小的值，接着与下一行合并。



