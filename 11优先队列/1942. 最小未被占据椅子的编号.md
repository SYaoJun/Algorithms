## 代码

-   方法：小根堆
-   时间复杂度：$O(NlogN)$
-   思路：首先将所有座位放入`pq`小根堆中，然后对朋友到来的时间表进行从小到大排序，依次遍历这个二维数组。每次将另外一个小根堆`q`中小于当前时刻的位置释放出来，加入到`pq`堆中，当前到达的朋友，从`pq`中取的就必然是最小的座位号。

```cpp
class Solution {
public:
    using PII = pair<int, int>;
    int smallestChair(vector<vector<int>>& times, int t) {
        priority_queue<int, vector<int>, greater<>> pq;
         priority_queue<PII, vector<PII>, greater<PII>> q;
        for(int i = 0; i <=10000; i++) pq.push(i);
        auto x = times[t];
        sort(times.begin(), times.end());
        for(int i = 0; i < times.size(); i++){
           auto a = times[i][0], b = times[i][1];
            while(q.size() && q.top().first <= a){
                auto e = q.top();
                q.pop();
                pq.push(e.second);
            }
            auto u = pq.top(); pq.pop();
            if(x == times[i]) return u;
            q.push({b, u});
        }
        return 0;
    }
};
```

