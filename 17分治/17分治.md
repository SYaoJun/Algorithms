## 经典例题

#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/) 中等 分治

```cpp

```

#### [373. 查找和最小的K对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/) 中等 优先队列 多路归并 小根堆

-   把最小的一组数放入小根堆中，然后每次取出最小的和，把下标往后移动。

```cpp
typedef vector<int> VI;

class Solution {
public:
    vector<vector<int>> kSmallestPairs(vector<int>& a, vector<int>& b, int k) {
        if (a.empty() || b.empty()) return {};
        int m = a.size(), n = b.size();
        priority_queue<VI, vector<VI>, greater<VI>> pq;
        for (int i = 0; i < n; i ++ ) 
                pq.push({a[0]+b[i], 0, i});
        vector<VI> res;
        while(k-- && pq.size()){
           auto t = pq.top();
            pq.pop();
             res.push_back({a[t[1]], b[t[2]]});
            if (t[1] + 1 < m)
                pq.push({a[t[1]+1]+b[t[2]], t[1]+1, t[2]});  
        }
        return res;
    }
};

```

#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/) 困难 自定义小根堆

-   注意链表为空不能加入优先队列
-   掌握自定义优先队列排序规则

```cpp
class Solution {
public:
    struct cmp{
        bool operator()(ListNode* a, ListNode* b){
            return a->val > b->val;
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
            // 优先队列
            priority_queue<ListNode*, vector<ListNode*>, cmp> pq; 
            for(auto list: lists){
                if(list) pq.push(list);
            }
            auto dummy = new ListNode(0);
            auto p = dummy;
            while(pq.size()){
                auto t = pq.top();
                pq.pop();
                p->next = t;
                if(t->next) pq.push(t->next);
                p = p->next;
            }
            return dummy->next;
    }
};
```



