## 图论

-   最短路
-   最小生成树
-   floyd算法
-   dijkstra算法
-   spfa算法

## 经典例题

#### [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/) 中等 

##### 方法1：floyd版本

```cpp
class Solution {
public:
    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& val, vector<vector<string>>& qu) {
        //转化为图论 用floyd求两两之间的最短距离
        unordered_map<string, unordered_map<string, double>> d;
        unordered_set<string> st;
        for(int i = 0; i < eq.size(); i++){
            auto a = eq[i][0], b = eq[i][1];
            auto c = val[i];
            d[a][b] = c;
            d[b][a] = 1/c;   
            st.insert(a);
            st.insert(b);
        }
        //floyd
        for(auto k: st){
            for(auto i: st){
                for(auto j: st){
                    if(d[i][k] && d[j][k])
                        d[i][j] = d[i][k]*d[k][j];
                }
            }
        }
        vector<double> res;
        for(auto &e: qu){
            auto a = e[0], b = e[1];
            if(d[a][b]) res.push_back(d[a][b]);
            else res.push_back(-1);
        }
        return res;
    }
};
```

##### 方法2：并查集

```cpp
class Solution {
public:
    int p[30];
    double v[30];
    int find(int x){
        if(p[x] != x) {
            int t = find(p[x]);
            v[x] *= v[p[x]]; 
            p[x] = t;
            
        }
        return p[x];
    }
    vector<double> calcEquation(vector<vector<string>>& eq, vector<double>& va, vector<vector<string>>& qu) {
        //确实是个不错的题目
        for(int i = 0; i <= 26; i++) {
            p[i] = i;
            v[i] = 1;
        }
        for(int i = 0; i < eq.size(); i++){
            auto e = eq[i];
            int a = e[0][0] - 'a';
            int b = e[1][0] - 'a';
            int fa = find(a), fb = find(b);
            if(fa != fb){
                p[fb] = fa;
                v[fa] *= va[i];
            }
        }
        vector<double> res;
        for(auto &e: qu){
            int a = e[0][0] - 'a';
            int b = e[1][0] - 'a';
            int fa = find(a), fb = find(b);
            if(e[0].size() > 1 || e[1].size() > 1) res.push_back(-1.0);
            if(fa == fb){
                res.push_back(v[fb]/v[fa]);
            }else res.push_back(-1.0);
        }
        return res;
    }
};
```

#### [797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/) M-

-   直接深搜
-   注意把n设置为全局变量时，不要在局部变量中重新定义，否则全局变量的`n=0`

```cpp
class Solution {
public:
    vector<int> temp;
    vector<vector<int>> res;
    vector<vector<int>> g;
    int n;
    void dfs(int u){
        temp.push_back(u);
        if(u == n-1){
            res.push_back(temp);
            temp.pop_back();
            return;
        }
        for(auto &x: g[u]){
            dfs(x);
        }
        temp.pop_back();
    }
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& _graph) {
        g = _graph;
        n = g.size();
        dfs(0);
        return res;
    }
};
```

