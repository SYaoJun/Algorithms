## 代码

-   时间复杂度：$O(N)$
-   方法：dp
-   思路：设定两个状态，遍历是修改两个状态的转换。

```cpp
class Solution {
public:
    using LL = long long;
    long long maxAlternatingSum(vector<int>& nums) {
        int n = nums.size();
        //根据长度为奇数和偶数进行分类讨论
        vector<vector<LL>> f(n+1, vector<LL>(2));
        //f[i][0]表示前面i位一共选了偶数个4 2 5 8
        for(int i = 0; i < n; i++){
            f[i+1][0] = max(f[i][0], f[i][1] - nums[i]);
            f[i+1][1] = max(f[i][1], max(0ll, f[i][0]) + nums[i]);
            // 选第i个和不选
            // 不选：直接沿用前面元素的结果
            // 选分为两种情况：1. 接在前面元素的后面 2.自己独立开始
        }
        
        return max(f[n][0], f[n][1]);
    }
};
```

-   方法：贪心
-   偶数下标只能取峰值，奇数下标只能取谷底。
-   注意：数值相等需要特殊处理

```cpp
class Solution {
public:
    using LL = long long;
    long long maxAlternatingSum(vector<int>& nums) {
        int n = nums.size();
        if(n == 1) return nums[0];
        LL res = 0;
        int cnt = 0;
        if(nums[0] > nums[1]){
            res += nums[0];
            cnt++;
        } 
        for(int i = 1; i < n-1; i ++){
            if(cnt&1){ //奇数减去小的
                if(nums[i] <= nums[i-1] && nums[i] < nums[i+1]) res -= nums[i], cnt++;
            }else{
                if(nums[i] >= nums[i-1] && nums[i] > nums[i+1]) res += nums[i], cnt++;
            }
        }
        
        if(cnt%2==0) res+= nums[n-1];
        return res;
    }
};
```

