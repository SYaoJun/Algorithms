## 代码

-   方法：前后缀拆分

```cpp
class Solution {
public:
    int minFlipsMonoIncr(string s) {
        // 前后缀拆分
        // 前一半全部变为0的操作数 + 后一半全部变为1的操作次数
        // 遍历每个位置，取最小值
        int n = s.size();
        s = ' ' + s;
        vector<int> l(n+2), r(n+2);
        for(int i = 1; i <= n; i++){
            if(s[i]=='1') l[i] = l[i-1] + 1;
            else l[i] = l[i-1];
        }
        
        for(int i = n; i >= 0; i--){
            if(s[i]=='0') r[i] = r[i+1] + 1;
            else r[i] = r[i+1];
        }
        
        int res = n;
        for(int i = 0; i <= n; i++){
            // 注意，这里必须要从0开始枚举，因为可能反转后全是1，不包含0
            res = min(res, l[i] + r[i+1]);
        }
        return res;
    }
};
```

-   方法：状态机dp
-   思路：`f[i][0]`表示前`i`个数中，以0结尾的最小修改次数。`f[i][1]`表示前`i`个数中，以1结尾的最小修改次数。其中0状态只能从前一个0转移过来，1可以由前一个1或者0转移过来。

```cpp
class Solution {
public:
    int minFlipsMonoIncr(string s) {
        int n = s.size();
        const int INF = 0x3f3f3f3f;
        vector<vector<int>> f(n+1, vector<int>(2, INF));
        s = ' ' + s;
        f[0][0] = f[0][1] = 0;
        for(int i = 1; i <= n; i++){
            int t = s[i] - '0';
            f[i][0] = f[i-1][0] + t;
            f[i][1] = min(f[i-1][0], f[i-1][1]) + (t^1);
        }
        return min(f[n][0], f[n][1]);
    }
};
```

