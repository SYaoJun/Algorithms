## 并查集

-   时间复杂度
    -   查询$O(1)$
    -   插入$O(logN)$
-   适用范围
    -   统计有多少个集合
    -   统计集合中最大有多少数

## 经典例题

#### [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/) 朋友圈数 中等 yxc

-   初始化p数组
-   默写出find函数
-   总的人数减去合并的次数，就等于最终独立的集合个数

```cpp
class Solution {
public:
    int n;
    int p[205];
    int find(int x){
        if(x != p[x]) p[x] = find(p[x]);
        return p[x];
    }
    int findCircleNum(vector<vector<int>>& M) {
        n = M.size();
        if(!n) return 0;
        for(int i = 0; i < n; i++) p[i] = i;
        int res = n;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(M[i][j]){
                    int  a = find(i), b = find(j);
                    if(a != b) p[a] = b, res--;
                }
            }
        }
        return res;
    }
};
```

#### [1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/) 中等 并查集 kruskal算法

-   注意需要把坐标映射成1到100000中的点，然后使用并查集。
-   注意两个int相乘是不会自动转换为long long的，需要强转。
-   未AC

```cpp
const int static N = 1e6+5;
struct edge{
    int x, y, dist;
}Edge[N];
class Solution {
public:
    int find(int x){
        if(root[x] != x) root[x] = find(root[x]);
        return root[x];
    }
    
    int root[N];
    
    bool static cmp(edge& a, edge& b){
        return a.dist < b.dist;
    }
    typedef long long LL;
    unordered_map<LL, int> mp;
    int idx = 1, m = 0;
    int minCostConnectPoints(vector<vector<int>>& points) {
        // 最小生成树 kruskal算法 本质是并查集
        int n = points.size();
        for(int i = 1; i < N; i++) root[i] = i;
        for(int i = 0; i < n; i++){
            for(int j = i+1; j < n; j++){
                int x = points[i][0], y = points[i][1];
                int u = points[j][0], v = points[j][1];
                LL p = x*(LL)N+y;
                LL q = u*(LL)N+v;
                int pp, qq;
                if(mp.count(p)) pp = mp[p];
                else {
                    mp[p] = idx++;
                    pp = mp[p];
                }
                if(mp.count(q)) qq = mp[q];
                else {
                    mp[q] = idx++;
                    qq = mp[q];
                }
                Edge[m++] = {pp, qq, abs(x-u)+abs(y-v)};
            }
        }
        sort(Edge, Edge+m, cmp);
        int res = 0;
        LL cost = 0;
        for(int i = 0; i < m; i++){
            int a = find(Edge[i].x);
            int b = find(Edge[i].y);
            if(a != b){
                root[a] = b;
                res++;
                cost += Edge[i].dist;
            }
            if(res == n-1) break;
        }
        
        return cost;
    }
};
```

#### [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/) 中等 

#### [990. 等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/) 中等 并查集

```cpp
class Solution {
public:
    int p[30];
    int find(int x){
        if(p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    bool equationsPossible(vector<string>& eq) {
        //先把所有等于合并
        for(int i  = 1; i <= 26; i++) p[i] = i;
        for(auto &s: eq){
            if(s[1] =='!') continue;
            int a = s[0] - 'a' + 1;
            int b = s[3] - 'a' + 1;
            int fa = find(a), fb = find(b);
            if(fa!=fb) p[fa] = fb;
        }
        
        //再判断所有不等
        for(auto &s: eq){
            if(s[1] =='=') continue;
            int a = s[0] - 'a' + 1;
            int b = s[3] - 'a' + 1;
            int fa = find(a), fb = find(b);
            if(fa==fb) return false;
        }
        return true;
    }
};
```

#### [1971. Find if Path Exists in Graph](https://leetcode-cn.com/problems/find-if-path-exists-in-graph/) E+

-   注意是无向图。
-   用并查集来做，最后判断start和end的父节点是否相同。

```cpp
class Solution {
public:
    vector<int> p;
    int find(int x){
        if(x != p[x]) p[x] = find(p[x]);
        return p[x];
    }
    bool validPath(int n, vector<vector<int>>& edges, int start, int end) {
        
        p.resize(n);
        for(int i = 0; i < n; i++) p[i] = i;
        for(auto &x: edges){
            int a = find(x[0]);
            int b = find(x[1]);
            if(a != b) {
                p[a] = b; 
            }
        }
        return find(start) == find(end);
    }
};
```



