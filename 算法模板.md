## 并查集

-   [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

```cpp
const int static N = 1e5+5;
int p[N];
int rank[N];
void init(){
    for(int i = 0; i < N; i++) {
        p[i] = i;
        rank[i] = i;
    }
}
int find(int x){
    if(p[x] == x) return x;
    return p[x] = find(p[x]);
}
void union_(int a, int b){
    int fa = find(a);
    int fb = find(b);
    if(fa != fb){
        p[fb] = fa; //合并
        rank[fa] += rank[fb];
    }
}
```

## SPFA

-   [1976. 到达目的地的方案数](https://leetcode-cn.com/problems/number-of-ways-to-arrive-at-destination/)

```cpp
class Solution {
public:
    const int static N = 110;
    int dist[N];
    bool st[N];
    using PII = pair<int, int>;
    vector<vector<PII>> g;
    void spfa(int s){
        memset(st, 0, sizeof st);
        memset(dist, 0x3f, sizeof dist);
        dist[s] = 0;
        queue<int> q;
        st[s] = true;
        q.push(s);
        while (!q.empty()) {
            int t = q.front();
            q.pop();
            // cout<<"t = "<<t<<endl;
            st[t] = false;
            for (const auto &[v, w]: g[t]) {
                if (dist[v] > dist[t] + w) {
                    dist[v] = dist[t] + w;
                    if (!st[v]) {
                        q.push(v);
                        st[v] = true;
                    }
                }
            }
        }
    }

    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        // spfa算法
        g.resize(n+1);
        for(auto t: times) {
            g[t[0]].push_back({t[1], t[2]});
        }
        spfa(k);
        int res = 0;
        for(int i = 1; i <= n; i++) {
            // cout<<"dist = "<<dist[i]<<endl;
            res = max(res, dist[i]);
        }
        if(res==0x3f3f3f3f) return -1;
        return res;
    }
};
```

## 欧拉筛素数

```cpp
using LL = long long;
static const int N = 1e5+5;
int pr[N];
int k = 0;
int p[N];
bool st[N];
void euler() {
    for(int i = 2; i < N; i++) {
        if(!st[i]) pr[k++] = i;
        for(int j = 0; pr[j] * i < N; j++) {
            st[i*pr[j]] = true;
            if(i % pr[j] == 0) break;
        }
    }
}
```

## floyd

-   [1334. 阈值距离内邻居最少的城市](https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)

```cpp
const int INF = 0x3f3f3f3f;
vector<vector<int>> g(n+1, vector<int>(n+1, INF));
for(int i = 1; i <= n; i++) {
    for(int j = 1; j <= n; j++){
        if(i == j) g[i][j] = 0;
    }
}

// floyd
for(int k = 1; k <= n; k++) {
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++){
            g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
        }
    }
}
```

## 滚动哈希

-   [1923. 最长公共子路径](https://leetcode-cn.com/problems/longest-common-subpath/)

```cpp
typedef uint64_t ULL;
typedef pair<ULL,ULL> PULL;
const static int N = 1e5+5; 
ULL head1[N], head2[N];
class Solution {
    ULL base1 = 1e5;
    ULL base2 = 1e5+7;
    ULL base3 = 1e9+7;
public:
    int longestCommonSubpath(int n, vector<vector<int>>& paths) 
    {
        // 预处理k次方数组
        head1[0] = 1, head2[0] = 1;
        for(int i = 1; i < base1; i++) {
            head1[i] = head1[i-1]*base1;
            head2[i] = head2[i-1]*base2;
        }
        int l = 0, r = 1e5;
        while (l < r){
            int mid =  (l + r + 1 ) >> 1;
            if (check(paths, mid))  l = mid;
            else r = mid - 1;                
        }
        return l;
    }
    
    bool check(vector<vector<int>>& paths, int len)
    {        
        unordered_map<ULL, int>HashCount;
        
        
            
        
        for (int k=0; k<paths.size(); k++)
        {
            unordered_set<ULL> HashSet;
            ULL hash1 = 0;
            ULL hash2 = 0;
            
            for (int i=0; i < paths[k].size(); i++)
            {
                if (i>=len)
                {
                    hash1 -= paths[k][i-len] * head1[len-1];
                    hash2 -= paths[k][i-len] * head2[len-1];
                }
                    
                hash1 = hash1 * base1 + paths[k][i];
                hash2 = hash2 * base2 + paths[k][i];
                
                auto t = hash1*base3 + hash2;
                if (i>=len-1 && HashSet.find(t)==HashSet.end())
                {
                    HashSet.insert(t);
                    HashCount[t]++;
                }                    
            }            
        }
        
        for (const auto &x: HashCount)
        {
            if (x.second == paths.size())
                return true;
        }
        return false;        
    }
};
```

## 字符串哈希

-   [1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)

```cpp
using ULL = unsigned long long;
static const int N = 1e5+5;
ULL p[N], h[N];
const int static P = 131;
ULL get(int l, int r){
    return h[r] - h[l-1] * p[r - l + 1];
}

// main
int n = s.size();
s = ' ' + s;
 p[0] = 1;
 for(int i = 1; i <= n; i++) {
     p[i] = p[i-1] * P;
     h[i] = h[i-1] * P + s[i];
 }
```

