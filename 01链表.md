#### [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/) 中等 拼接 经典

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/) 中等 yxc 快慢指针

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) 简单 yj 链表

-   一遍修改指针的指向，一遍移动原链表的指针。

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr, *next;
        while(head){
            next = head->next;
            head->next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }   
};
```



#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) 简单 归并排序

#### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/) 简单 面试常考题 双指针

#### [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/) 中等 面试常考 双指针 保留前一个指针

#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/) 简单 面试题常考 反转链表 快慢指针 

#### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/) 困难 yxc 链表

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode p = dummy;
        while(p != null){
            ListNode q = p;
            for(int i = 0; i < k && q != null; i++){
                q = q.next;
            }
            if(q == null) break;
            ListNode next, a = p.next, b = a.next;
            for(int i = 0; i < k-1; i++){
                next = b.next;
                b.next = a;
                a = b;
                b = next;
            }
            ListNode c = p.next;
            p.next = a;
            c.next = b;
            p = c;
        }
        return dummy.next;
    }
}
```

#### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/) 困难 yxc 堆优化 链表

-   把每个非空的链表头加入堆中，每次取堆中的最小值进行合并

```cpp
class Solution {
public:
    struct cmp{
        bool operator()(ListNode* a, ListNode* b){
            return a->val > b->val;
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // yxc nb 2021.4.24
        //使用小根堆存储每个链表中最小的元素
        priority_queue<ListNode*, vector<ListNode*>, cmp> pq;
         for(auto list: lists){
            if(list) pq.push(list);
        }
        auto dummy = new ListNode();
        auto p = dummy;

        while(pq.size()){
            auto t = pq.top();
            pq.pop();
            p->next = t;
            p = p->next;
            if(t->next) pq.push(t->next);
        }
        return dummy->next;
    }
};

```

