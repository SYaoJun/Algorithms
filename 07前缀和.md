#### [363. 矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/) 困难 yxc 

-   二维前缀和，注意下标是从1开始的
-   集合维护有序，使用lower_bound获取最大值

```cpp
class Solution {
public:
    int get(vector<vector<int>>& s, int x1, int y1, int x2, int y2){
        return s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];
    }
    int maxSumSubmatrix(vector<vector<int>>& mat, int K) {
        // 二维前缀和
        //由于行数大于列数 所以枚举少的
        int m = mat.size();
        int n = mat[0].size();
        vector<vector<int>> s(m+1, vector<int>(n+1));
        
        //求出前缀和
        for(int i = 1; i <= m; i++)
            for(int j = 1; j <= n; j++){
                s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + mat[i-1][j-1];
            }
        //枚举列
        // s[i] - s[k] <= k
        // s[k] >= s[i] - k 使用集合的lower_bound
        int res = INT_MIN;
        for(int i = 1; i <= n; i++){
            for(int j = i; j <= n; j++){
                set<int> st;
                st.insert(0);
                for(int k = 1; k <= m; k++){
                    int si = get(s, 1, i, k, j);
                    auto t = st.lower_bound(si - K);
                    if(t != st.end()) res = max(res, si - *t);
                    st.insert(si);
                }
            }
        }
        return res;
    }
};
```

#### [930. 和相同的二元子数组](https://leetcode-cn.com/problems/binary-subarrays-with-sum/) 中等 yxc

#### [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/) 中等 同余定理 注意处理取余为负数的情况

#### [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/) 中等 yxc 差分数组  双指针

-   使用双指针遍历一段连续的等差数列区间。
-   当连续的差分数组从`i`到`j`则，这段区间内的差分数组个数为`(j-i)*(j-i-1)/2` ，注意`j-i`必须要大于1这样才能保证原数组有3个及以上的数组成。

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        // 差分数组 + 找规律 yxc 2021.8.8
        int n = nums.size();
        for(int i = n-1; i > 0; i--){
            nums[i] = nums[i] - nums[i-1];
        }
        //找每个连续数值的长度
        int res = 0;
        for(int i = 1; i < n;){
            int j = i;
            while(j < n && nums[i] == nums[j]) j++;
            int k = j - i;
            if(k < 1) continue;
            res += k*(k-1)/2;
            i = j;
        }
        return res;
    }
};
```

